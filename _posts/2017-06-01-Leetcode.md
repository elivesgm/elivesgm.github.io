---
layout: post
title: "Leetcode"
date: 2017-06-01 07:37:06 
description: "Algorithm Realization on Leetcode"
tag: Algorithm
---


### 1. Substring with Concatenation of All Words

You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

For example, given:
s: "barfoothefoobarman"
words: ["foo", "bar"]

You should return the indices: [0,9].
(order does not matter).

**思路**：从s中连续依次查找words中的word，查找完words中所有word则记录indices，如果没有查找到words中的任何一个word或者查找个数大于期望个数（后面这个情况是否存在？），退出此次查找。查找成功则直接跨过All words的长度重新开始查找，否则从下个位置开始重新查找。

	#include <vector>
	#include <string>
	#include <unordered_map>
	using namespace std;
	
	vector<int> findSubstring(string s, vector<string>& words) {
		vector<int> indices;
		unordered_map<string, int> count;
		int len_s = s.length();
		int len_w = words[0].length();
		int num = words.size();
		for(int i = 0; i < num; ++i)
			count[ words[i] ]++;
		for (int i = 0; i < len_s - len_w * num + 1;) {
			unordered_map<string, int> find_count;
			int j = 0;
			for (; j < num;j++) {
				string word = s.substr(i + j * len_w, len_w);
				if (count.find(word) != count.end()) {
					find_count[word]++;
					if (find_count[word] > count[word]) //whether necessary?
						break;
				}
				else
					break;
			}
			if (j == num) {
				indices.push_back(i);
				i += len_w * num;
			}
			else ++i;
		}
		return indices;	
	}

**知识点**： unordered_map[1]

header file: \#include <unordered_map\>

>Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value, and which allows for fast retrieval of individual elements based on their keys.

>In an unordered_map, the key value is generally used to uniquely identify the element, while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ.

>Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (**with a constant average time complexity on average**).

>**unordered_map containers are faster than map containers to access individual elements by their key**.

>Unordered maps implement the direct access operator (operator[]) which allows for direct access of the mapped value using its key value as argument.

>Iterators to elements of unordered_map containers access to both the key and the mapped value. For this, the class defines what is called its value_type, which is a pair class with its first value corresponding to the const version of the key type (template parameter Key) and its second value corresponding to the mapped value (template parameter T):

	typedef pair<const Key, T> value_type;

>Iterators of a unordered_map container point to elements of this value_type. Thus, for an iterator called it that points to an element of a map, its key and mapped value can be accessed respectively with:

	unordered_map<Key,T>::iterator it;
	(*it).first;             // the key value (of type Key)
	(*it).second;            // the mapped value (of type T)
	(*it);                   // the "element value" (of type pair<const Key,T>)

>Naturally, any other direct access operator, such as -> or [] can be used, for example:

	it->first;               // same as (*it).first   (the key value)
	it->second;              // same as (*it).second  (the mapped value) 


### References

[1] [unordered_map](http://www.cplusplus.com/reference/unordered_map/unordered_map/), cplusplus.com.